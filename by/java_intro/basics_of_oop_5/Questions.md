  # 5 Basics of OOP

  *Этот список вопросов предназначен для самостоятельного контроля глубины изучаемого материала.*
  *Попробуйте выучить материал так, чтобы вы могли ответить (хоть пару слов) по каждому вопросу.*

  ### OOP, Classes and Objects, Inheritance, Class Object, Interfaces 
    
  1.  Дайте развернутое объяснение трем концепциям ООП
  <br/>Ответ:<br/>
  Наследование - механизм создания классов на основе существующих.
  </br>Инкапсуляция - сокрытие реализации.
  </br>Полиморфизм - способность одинаково использовать разные объекты с одинаковым интерфейсом.

  2.  Опишите процедуру инициализации полей класса и полей экземпляра класса. Когда инициализируются поля класса, а когда – поля экземпляров класса. Какие значения присваиваются полям по умолчанию? Где еще в классе полям могут быть присвоены начальные значения?
  <br/>Ответ:<br/>
  Поле класса по умолчанию 0 для примитивных типов, null для ссылок. Инициализировать другими значениями можно при объявлении или в динамическом и статическом (для статичных полей) блоках. Поля экземпляров инициализируются при создании объектов в конструкторе, методах (например сеттеры) или прямо при публичном модификаторе доступа поля.
  
  3.  Приведите правила, которым должен следовать компонент java-bean
  <br/>Ответ:<br/>
  - иметь public конструктор без параметров
  - поля класса должны быть доступны через get и set (и другие методы, которые должны подчиняться стандартному соглашению об именах)
  - класс должен реализовывать интерфейс Serializable
  - класс должен иметь переопределенные методы equals, hashCode, toString.

  4.  Дайте определение перегрузке методов. Как вы думаете, чем удобна перегрузка методов? Укажите, какие методы могут перегружаться, и какими методами они могут быть перегружены? Можно ли перегрузить методы в базовом и производном классах?  Можно  ли  private  метод  базового  класса  перегрузить  public  методов  производного?  Можно  ли  перегрузить конструкторы, и можно ли при перегрузке конструкторов менять атрибуты доступа у конструкторов? 
  <br/>Ответ:<br/>
  Перегрузка методов - это создание внутри одного класса методов с одинаковыми именами, но разными входными параметрами. Удобство в отсутствии необходимости придумывать новые имена методам, выполняющих схожие задачи. Любые методы могут быть перегружены. Методы с разными аргументами в базовом и производном классах не являются перегрузкой. Private метод базового класса нельзя перегрузить public методом производного. Конструкторы можно перегружать, также можно при перегрузке конструкторов менять атрибуты доступа у конструкторов.

  5.  Объясните, что такое раннее и позднее связывание? Перегрузка – это раннее или позднее связывание? Объясните правила, которым  следует  компилятор  при  разрешении  перегрузки;  в  том  числе,  если  методы  перегружаются  примитивными типами, между которыми возможно неявное приведение или ссылочными типами, состоящими в иерархической связи. 
  <br/>Ответ:<br/>
  Раннее связывание - на этапе компиляции (static, final), позднее связывание - в рантайме (virtual в Java по умолчанию). Перегрузка - раннее связывание. </br>
  Вызывается метод, соответствующих типу переданного аргумента. В случае примитивных типов при передаче значения можно добавить соответствующий идентификатор (. l f). При передаче ссылок, состоящих в иерархической связи вызывается метод, соответствующий типу переданной ссылки, а не объекту, на который она ссылается.

  6.  Объясните, как вы понимаете, что такое неявная ссылка this? В каких методах эта ссылка присутствует, а в каких – нет, и почему?
  <br/>Ответ:<br/>
  this - это ссылка на текущий экземпляр класса. Присутствует в нестатических методах, отсутствует в статических, потому что не на что ссылаться.

  7.  Что  такое  финальные поля, какие поля можно  объявить  со  спецификатором  final?  Где  можно  инициализировать финальные поля?
  <br/>Ответ:<br/>
  Финальные поля - это поля, инициализировать которые можно только один раз, и после этого изменить нельзя. Со спецификатором final можно объявить классы, методы, поля. Инициализировать финальные поля можно сразу при объявлении, в блоке инициализации, в конструкторе, а static final в статическом блоке инициализации.

  8.  Что такое статические поля, статические финальные поля и статические методы. К чему имеют доступ статические методы? Можно ли перегрузить и переопределить статические методы? Наследуются ли статические методы?
  <br/>Ответ:<br/>
  Статические поля и методы - поля и методы, доступные без создания экземпляра класса. Статические финальные поля - тоже самое, плюс неизменяемые. Статические методы имеют доступ только к статическим полям и методам. Статические методы можно перегрузить, но нельзя переопределить. Статические методы наследуются.

  9.  Что такое логические и статические блоки инициализации? Сколько их может быть в классе, в каком порядке они могут быть размещены и в каком порядке вызываются?
  <br/>Ответ:<br/>
  Логические блоки инициализации - это участки кода, находящиеся внутри класса, но вне методов. Статические блоки инициализации - тоже самое, но со словом static. Сначала вызываются статические блоки в порядке объявления, потом нестатические, тоже в порядке объявления.

  10.  Что представляют собой методы с переменным числом параметров, как передаются параметры в такие методы и что представляет собой такой параметр в методе? Как осуществляется выбор подходящего метода, при использовании перегрузки для методов с переменным числом параметров? 
  <br/>Ответ:<br/>
  Методы с переменным числом параметров могут принимать в качестве аргументов неопределенное кол-во параметров, которые передаются списком через запятую. Объявляется такой метод как func_name(type ... v). Выбор функции при перегрузке осуществляется как и в обычном методе.

  11.  Чем является класс Object? Перечислите известные вам методы класса  Object, укажите их назначение. 
  <br/>Ответ:<br/>
  Класс Object является родительским классом всех классов. Его методы: 
  * public final Class<?> getClass() - возвращает класс объекта
  * public int hashCode() - возвращает хеш-код объекта
  * public boolean equals(Object obj) - возвращает истинность одинаковости объектов
  * protected Object clone() - создает и возвращает копию объекта
  * public String toString() - возвращает строковое представление объекта
  и другие.

  12.  Что такое хэш-значение? Объясните, почему два разных объекта могут сгенерировать одинаковые хэш-коды? 
  <br/>Ответ:<br/>
  Хеш-значение - результат работы хеш-функции. (Значение фиксированной длинны, сопоставляемое определенным входным данным). Два разных объекта могут сгенерировать одинаковые хэш-коды из-за ограниченной длины хеш-кода.

  13.  Как вы думаете, для чего используется наследование классов в java-программе? Приведите пример наследования. Как вы думаете, поля и методы, помеченными модификатором доступа private, наследуются? 
  <br/>Ответ:<br/>
  Для создание иерархии классов, соответствующей предметной области, для которой создается программа. 
  <pre><code>
  abstract class Shape {
    abstract double getVolume();
  }
  class Cube extends Shape {
    double getVolume() {return a*a*a;}
  }
  class Sphere extends Shape {
    double getVolume() {return 4.*pi*r*r*r/3.;}
  }
  </code></pre>
  Нет, поля и методы, помеченными модификатором доступа private, не наследуются.

  14.  Укажите, как вызываются конструкторы при создании объекта производного класса? Что в конструкторе класса делает оператор super()? Возможно ли в одном конструкторе использовать операторы super() и this()? 
  <br/>Ответ:<br/>
  Неявно вызывается конструктор по умолчанию родителя, если не вызывается другой через super, потом код конструктора производного класса. Оператор super вызывает конструктор родительского класса. Нельзя в одном конструкторе использовать операторы super() и this(), т.к. они оба должны быть в первой строке конструктора.

  15.  Объясните, как вы понимаете утверждения: “ссылка базового класса может ссылаться на объекты своих производных типов” и “объект производного класса может быть использован везде, где ожидается объект его базового типа”. Верно ли обратное и почему? 
  <br/>Ответ:<br/>
  Эти утверждения означают одно и то же. Обратно, т.е. "ссылка производного класса может ссылаться на объекты своих базовых типов" и "объект базового класса может быть использован везде, где ожидается объект его производного типа" - неверные утверждения, т.к. в базовых типах может не быть тех интерфейсов, которые есть в производных, но обратное (интерфейсы базового есть в производных) выполняется всегда, поэтому изначальные выражения верны.

  16.  Что такое переопределение методов? Как вы думаете, зачем они нужны? Можно ли менять возвращаемый тип при переопределении методов? Можно ли менять атрибуты доступа при переопределении методов? Можно ли переопределить методы в рамках одного класса?
  <br/>Ответ:<br/>
  Переопределение методов - создание методов в производных классах с одинаковыми сигнатурами и возвращаемыми типами, что и в базовых классах. Оно нужно для полиморфизма. Нет, менять тип при переопределении методов нельзя. При переопределении методов менять атрибуты доступа можно только в сторону увеличения видимости. Переопределить методы в рамках одного класса невозможно.

  17.  Определите правило вызова переопределенных методов. Можно ли статические методы переопределить нестатическими и наоборот?
  <br/>Ответ:<br/>
  При вызове, выполняется метод класса экземпляра, а не класса ссылки. Статические методы переопределить нестатическими нельзя, наоборот - тоже нельзя. 

  18.  Какие свойства имеют финальные методы и финальные классы? Как вы думаете, зачем их использовать? 
  <br/>Ответ:<br/>
  Финальные методы нельзя переопределить, от финальных классов нельзя наследоваться.  Финальные классы - для запрета наследования или для создания неизменяемых классов. Финальный метод - для создания методов, которые будут делать одно и то же во всем дереве наследования.

  19.  Укажите правила приведения типов при наследовании. Напишите примеры явного и неявного преобразования ссылочных типов. Объясните, какие ошибки могут возникать при явном преобразовании ссылочных типов. 
  <br/>Ответ:<br/>
  Восходящее (upcasting) - неявное преобразование от подкласса внизу к суперклассу вверху иерархии:
  <pre><code>
  Number n = new Integer(5);
  </code></pre>
  Нисходящее преобразование (downcasting) явное:
  <pre><code>
  Number n = new Integer(5);
  Integer five = (Integer)n;
  </code></pre>
  При явном преобразовании ссылочных типов может возникать java.lang.ClassCastException при преобразовании к неверному типу.

  20.  Что такое объект класса Class? Чем использование метода getClass() и последующего сравнения возвращенного значения с Type.class отличается от использования оператора instanceof? 
  <br/>Ответ:<br/>
  Объект класса Class представляет классы и интерфейсы в запущенном приложении. Сравнение class и getClass() будет true, только если классы совпадают, instanceof же вернет true, также когда сравниваются класс и его родитель.

  21.  Укажите правила переопределения методов equals(), hashCode() и toString().
  <br/>Ответ:<br/>
  Соблюдать контракты hashCode и equals. toString желательно переопределять всегда (чтобы не выводил неинформативную информацию). </br> 
  Контракт equals (equals должен быть):
  * рефлексивным (x.equals(x) = true)
  * симметричным (y.equals(x) = x.equals(y))
  * транзитивным (если x.equals(y) = true и y.equals(z) = true, то x.equals(z) = true)
  * консистентным (если не менялись объекты, то и equals не должен изменить возвращаемое значение)
  </br>
  Контракт hashCode:
  * внутренняя консистентность (не менялся объект - не меняется и hashCode)
  * консистентность с equals (если x.equals(y) = true, то и x.hashCode() = y.hashCode())
  * коллизии (даже если x.equals(y) = false, но hashCode могут совпадать)

  22.  Что такое абстрактные классы и методы? Зачем они нужны? Бывают ли случаи, когда абстрактные методы содержат тело? Можно  ли  в  абстрактных  классах  определять  конструкторы?  Могут  ли  абстрактные  классы  содержать  неабстрактные методы? Можно ли от абстрактных классов создавать объекты и почему? 
  <br/>Ответ:<br/>
  Абстрактные классы - нельзя создавать экземпляры. Абстрактные методы - нет тела. Они нужны для создания иерархии классов. Абстрактные методы не могут содержать тело. В абстрактных классах можно определять конструкторы. Абстрактные классы могут содержать неабстрактные методы. От абстрактных классов нельзя создавать объекты, т.к. в них могут быть абстрактные методы без тела, вызывать которые не получится.

  23. Что такое интерфейсы? Как определить и реализовать интерфейс в java-программе? Укажите спецификаторы, которые приобретают методы и поля, определенные в интерфейсе. Можно ли описывать в интерфейсе конструкторы и создавать объекты? Можно ли создавать интерфейсные ссылки и если да, то на какие объекты они могут ссылаться? 
  <br/>Ответ:<br/>
  Интерфейсы описывают совокупность методов, которыми должны обладать классы, реализующие этот интерфейс. Определение и реализация интерфейса:
  <pre><code>
  interface Movable {
    public void move();
  }
  class Duck implements Movable {
    public void move() {
      System.out.println("Duck is moving");
    }
  }
  </code></pre>
  Методы и поля, определенные в интерфейсе, приобретают спецификаторы public. Описывать в интерфейсе конструкторы и создавать объекты нельзя. Создавать интерфейсные ссылки можно, ссылаться такими ссылками можно только на объекты классов, реализующие данный интерфейс.

  24. Для чего служит интерфейс Clonable? Как правильно переопределить метод clone() класса Object, для того, что объект  мог создавать свои адекватные копии? 
  <br/>Ответ:<br/>
  Интерфейс Clonable служит для клонирования объектов. Если поля содержат ссылочные типы, то их тоже нужно клонировать (или создать новые, но одинаковые); повторять эту процедуру, пока не останутся поля только примитивных типов.

  25. Для чего служат интерфейсы Comparable и Comparator? В каких случаях предпочтительнее использовать первый, а когда  – второй? Как их реализовать и использовать?   
  <br/>Ответ:<br/>
  Comparable - функциональный интерфейс, содержащий метод compareTo. Comparator - интерфейс, содержащий много методов для сравнения. Comparable используется для быстрой реализации сравнения, но необходимо редактировать класс. Comparator же позволяет реализовать разные способы сортировки, и для его использования редактировать сравниваемый класс не нужно. Пример:
  <pre><code>
  class MyNumber implements Comparable<MyNumber> {
    private int n;
    MyNumber(int n) {
      this.n = n;
    }

    public int getN() {
      return n;
    }

    int compareTo(MyNumber o) {
      if (o.n < n) {
        return 1;
      } else if (o.n > n) {
        return -1;
      } else {
        return 0;
      }
    }
  }

  class MyNumberComparator implements Comparator<MyNumber> {
    int compare(MyNumber n1, MyNumber n2) {
      if (n1.getN() < n2.getN()) {
        return -1;
      } else if (n1.getN() > n2.getN()) {
        return 1;
      } else {
        return 0;
      }
    }
  }
  </code></pre> 
  
  ### Generic classes and Interfaces, Enums

  1.  Что такое перечисления в Java. Как объявить перечисление? Чем являются элементы перечислений? Кто и когда создает экземпляры перечислений?
  <br/>Ответ:<br/>
  Перечисления - список именованных констант. Объявить перечисление можно с помощью enum. Элементы перечислений - это экземпляры класса перечисления. Java создает все экземпляры перечислений при запуске, если используется хоть один экземпляр.

  2.  Можно  ли  самостоятельно  создать  экземпляр  перечисления?  А  ссылку  типа  перечисления?  Как  сравнить,  что  в  двух  переменных содержится один и тот же элемент перечисления и почему именно так? 
  <br/>Ответ:<br/>
  Нельзя  самостоятельно  создать  экземпляр  перечисления. А ссылку - можно. Сравнить через equals, потому что объект один, и одинаковые ссылки ссылаются на один и тот же объект, значит реализация equals Object'а нам подходит.

  3.  Что такое анонимные классы?  
  <br/>Ответ:<br/>
  Анонимные классы - внутренние классы без названия.

  4.  Что такое параметризованные классы? Для чего они необходимы? Приведите пример параметризованного класса и пример  создания  объекта  параметризованного  класса?  Объясните,  ссылки  какого  типа  могут  ссылаться  на  объекты  параметризованных классов? Можно ли создать объект, параметризовав его примитивным типом данных?
  <br/>Ответ:<br/>
  Параметризованные классы - это классы, в которых тип указан в качестве параметра. Они необходимы для общего описания множества классов, отличающихся лишь типом данных. Пример:
    <pre><code>
  class MyClass<T> {
    private T value;
    MyClass(T value) {
      this.value = value;
    }

    public T getValue() {
      return value;
    }
  }

  MyClass<Integer> myClass = new MyClass<>(6); 
  </code></pre> 
  Оператор <> - синтаксический сахар. Ссылки работают как обычно, но с условием того, что параметры типа в ссылке и объекте должны совпадать или ссылка должна быть без параметра. Нельзя создать объект, параметризовав его примитивным типом данных.

  ### Exceptions and Errors

  1.  Что для программы является исключительной ситуацией? Какие способы обработки ошибок в программах вы знаете? 
  <br/>Ответ:<br/>
  Для программы является исключительной ситуацией невозможность дальнейшего выполнения. Способом обработки ошибок является создание try-catch блоков.

  2.  Что  такое  исключение  для  Java-программы?  Что  значит  “программа  выбросила  исключение”?  Опишите  ситуации,  когда  исключения выбрасываются виртуальной машиной(автоматически), и когда необходимо их выбрасывать вручную?  
  <br/>Ответ:<br/>
  Для Java-программы является исключительной ситуацией создание объекта Throwable. “Программа  выбросила  исключение” - означает появление исключительной ситуации, которая не была обработана самой программой, и была выведена пользователю. Исключения делятся на checked и unchecked, первые создаются вручную, вторые - автоматически.

  3.  Приведите иерархию классов-исключений, делящую  исключения  на проверяемые и  непроверяемые.  В  чем  особенности  проверяемых и непроверяемых исключений? 
  <br/>Ответ:<br/>
  * Throwable
    - Exception (checked)
      * RuntimeException (unchecked)
    - Error (unchecked)
  Проверяемые создаются вручную, и можно заранее объявить об их возможном появлении. Непроверяемые создаются автоматически, их появление объявлять бессмысленно.
  
  4.  Объясните работу  оператора try-catch-finally. Когда данный оператор следует  использовать? Сколько  блоков  catch  может  соответствовать одному блоку try?  Можно ли вкладывать блоки try друг  в друга, можно ли вложить блок try в catch  или  finally?  Как  происходит  обработка  исключений,  выброшенных внутренним  блоком  try,  если  среди  его блоков  catch  нет  подходящего? Что называют стеком операторов try? Как работает блок try с ресурсами. 
  <br/>Ответ:<br/>
  В блоке try код, который может создать исключение, в блоках catch происходит перехват соответствующих типов исключений, в блоке finally код, который выполнится в любом случае. Использовать следует при обработке исключений. Соответствовать одному блоку try может любое кол-во блоков catch. Можно вкладывать блоки try друг в друга, можно  вложить блок try в catch или finally. Обработка  исключений,  выброшенных внутренним  блоком  try,  если  среди  его блоков  catch  нет  подходящего, происходит через выброс исключения на уровень выше. Стеком операторов try называется последовательность всех пройденных исключением блоков try. Блок try с ресурсами позволяет инициализировать в специальном блоке в начале ресурсы, имплементирующие AutoCloseable, и закрывать эти ресурсы при выходе из блока try.

  5.  Укажите  правило  расположения  блоков  catch  в  зависимости  от  типов  перехватываемых  исключений.  Может  ли  перехваченной исключение быть сгенерировано снова, и, если да, то как и кто в этом случае будет обрабатывать повторно  сгенерированное исключение? Может ли блок catch выбрасывать иные исключения, и если да, то опишите ситуацию, когда  это может быть необходимо.
  <br/>Ответ:<br/>
  Блоки catch располагаются в порядке от более конкретных к более общим. Повторно сгенерированное исключение передается на уровень выше. Блок catch  может выбрасывать иные исключения (которые не перехватываются catch) при невозможности их обработки, чтобы их обработали выше.

  6.  Когда происходит вызов блока finally? Существуют ли ситуации, когда блок finally не будет вызван? Может ли блок finally  выбрасывать исключений? Может ли блок finally выполниться дважды? 
  <br/>Ответ:<br/>
  Вызов блока finally происходит после выполения блоков try и catch (если он был вызван). Не существуют ситуации, когда блок finally не будет вызван. Блок finally может выбрасывать исключения. Блок finally не может выполниться дважды.

