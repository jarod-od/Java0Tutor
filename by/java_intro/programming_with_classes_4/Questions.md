  # 4 Programming with classes

  *Этот список вопросов предназначен для самостоятельного контроля глубины изучаемого материала.*
  *Попробуйте выучить материал так, чтобы вы могли ответить (хоть пару слов) по каждому вопросу.* 
    
  1.   Опишите процедуру инициализации полей класса и полей экземпляра класса. Когда инициализируются поля класса, а когда – поля экземпляров класса. Какие значения присваиваются полям по умолчанию? Где еще в классе полям могут быть присвоены начальные значения? 
  <br/>Ответ:<br/>
  Поле класса по умолчанию 0 для примитивных типов, null для ссылок. Инициализировать другими значениями можно при объявлении или в динамическом и статическом (для статичных полей) блоках. Поля экземпляров инициализируются при создании объектов в конструкторе или в методах (например сеттеры).

  2.  Дайте определение перегрузке методов. Как вы думаете, чем удобна перегрузка методов? Укажите, какие методы могут перегружаться, и какими методами они могут быть перегружены? Можно ли перегрузить методы в базовом и производном классах? Можно ли private метод базового класса перегрузить public методов производного? Можно ли перегрузить конструкторы, и можно ли при перегрузке конструкторов менять атрибуты доступа у конструкторов? 
  <br/>Ответ:<br/>
  Перегрузка методов - это создание внутри одного класса методов с одинаковыми именами, но разными входными параметрами. Удобство в отсутствии необходимости придумывать новые имена методам, выполняющих схожие задачи. Любые методы могут быть перегружены. Методы с разными агрументами в базовом и производном классах не являются перегрузкой. Private метод базового класса ytkmpz перегрузить public методом производного. Конструкторы можно перегружать, также можно при перегрузке конструкторов менять атрибуты доступа у конструкторов.

  3.  Объясните, что такое раннее и позднее связывание? Перегрузка – это раннее или позднее связывание? Объясните правила,  которым  следует  компилятор  при  разрешении  перегрузки;  в  том  числе,  если  методы  перегружаются примитивными типами, между которыми возможно неявное приведение или ссылочными типами, состоящими в иерархической связи. 
  <br/>Ответ:<br/>
  Раннее связывание - на этапе компиляции (static, final), позднее связываение - в рантайме (virtual в Java по умолчанию). Перегрузка - раннее связывание. </br>
  Вызывается метод, соответствующих типу переданного аргемента. В случае примитивных типов при передаче значения можно добавить соответствующий иденитификатор (. l f). При передаче ссылок, состоящих в иерархической связи вызывается метод, соответствующий типу переданной ссылки, а не объекту, на который она ссылается.

  4.  Объясните, как вы понимаете, что такое неявная ссылка this? В каких методах эта ссылка присутствует, а в каких – нет, и почему?
  <br/>Ответ:<br/>
  this - это ссылка на текущий экземпляр класса. Присутствует в нестатических методах, отсутствует в статических, потому что не на что ссылаться.

  5.  Что  такое  финальные поля, какие поля можно  объявить  со  спецификатором  final?  Где  можно  инициализировать финальные поля?
  <br/>Ответ:<br/>
  Финальные поля - это поля, инициализировать которые можно только один раз, и после этого изменить нельзя. Со спецификатором final можно объявить классы, методы, поля. Инициализировать финальные поля можно сразу при объявлении, в блоке инициализации, в конструкторе, а static final в статическом блоке инициализации.

  6.  Что такое статические поля, статические финальные поля и статические методы. К чему имеют доступ статические методы? Можно ли перегрузить и переопределить статические методы? Наследуются ли статические методы?
  <br/>Ответ:<br/>
  Статические поля и методы - поля и методы, достуные без создания экземпляра класса. Статические финальные поля - тоже самое, плюс неизменяемые. Статические методы имеют доступ только к статическим полям и методам. Статические методы можно перегрузить, но нельзя переопределить. Статические методы наследуются.

  7.  Что такое логические и статические блоки инициализации? Сколько их может быть в классе, в каком порядке они могут быть размещены и в каком порядке вызываются?
  <br/>Ответ:<br/>
  Логические блоки инициализации - это участки кода, находящиеся внутри класса, но вне методов. Статические блоки инициализации - тоже самое, но со словом static. Сначала вызываются статические блоки в порядке объявления, потом нестатические, тоже в порядке объявления.

  8.  Что представляют собой методы с переменным числом параметров, как передаются параметры в такие методы и что представляет собой такой параметр в методе? Как осуществляется выбор подходящего метода, при использовании перегрузки для методов с переменным числом параметров? 
  <br/>Ответ:<br/>
  Методы с переменным числом параметров могут принимать в качестве агрументов неопределенное кол-во параметров, которые передаются списком через запятую. Объявляется такой метод как func_name(type ... v). Выбор функции при перегрузке осуществляется как и в обычном методе.

  9.  Чем является класс Object? Перечислите известные вам методы класса  Object, укажите их назначение. 
  <br/>Ответ:<br/>
  Класс Object является родительским классом всех классов. Его методы: 
  * public final Class<?> getClass() - возвращает класс объекта
  * public int hashCode() - возвращает хеш-код объекта
  * public boolean equals(Object obj) - возвращает истинность одинаковости объектов
  * protected Object clone() - создает и возвращает копию объекта
  * public String toString() - возвращает строковое представление объекта
  и другие.

  10.  Что такое хэш-значение? Объясните, почему два разных объекта могут сгенерировать одинаковые хэш-коды? 
  <br/>Ответ:<br/>
  Хеш-значение - результат работы хеш-функции. (Значение фиксированной длинны, сопоставляемое определенным входным данным). Два разных объекта могут сгенерировать одинаковые хэш-коды из-за ограниченной длины хеш-кода.

  11.  Что  такое  объект  класса  Class?  Чем  использование  метода  getClass()  и  последующего  сравнения  возвращенного значения с Type.class отличается от использования оператора instanceof? 
  <br/>Ответ:<br/>
  Объект класса Class представляет классы и инитерфейсы в запущенном приложении. Сравнение class и getClass() будет true, только если классы совпадают, instanceof же вернет true, также когда сравниваются класс и его родитель.

  12.  Укажите правила переопределения методов equals(), hashCode() и toString().
  <br/>Ответ:<br/>
  Соблюдать контракты hashCode и equals. toString желательно переопределять всегда (чтобы не выводил неиформативную информацию). </br> 
  Контракт equals (equals должен быть):
  * рефлексивным (x.equals(x) = true)
  * симметричеым (y.equals(x) = x.equals(y))
  * транзитивным (если x.equals(y) = true и y.equals(z) = true, то x.equals(z) = true)
  * консистентным (если не менялись объекты, то и equals не должен изменить возвращаемое значение)
  </br>
  Контракт hashCode:
  * внутренняя консистентность (не менялся объект - не меняется и hashCode)
  * консистентность с equals (если x.equals(y) = true, то и x.hashCode() = y.hashCode())
  * коллизии (даже если x.equals(y) = false, но hashCode могут совпадать)

  
